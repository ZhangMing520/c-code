1. 模板函数

> 类型参数 T 表示类型

> 当我们调用这个 median 函数的时候，系统环境会在编译期间把它判定的一个类型赋给 T。
> 例如，我们可以调用 median(vi) 从而给 median 函数一个 vector\<int> 类型的名为 vi 的对象。根据这个调用，系统环境就能推断出 T 是 int。

> 实际上，系统环境会对我们的代码进行实例化，就好像我们编写了一个参数类型为 vector\<int>、返回类型为 int 的特殊版本的 median 函数一样。

```cpp
// template <class T> 模板头
template <class T>
T median(vector<T> v)
{
    /* code */ 
}
```

2. typename

> 它会告知系统环境，vector<T>::size_type 是一个类型名 -- 即使系统环境还不知道类型 T 具体是代表什么的

```cpp
typedef typename vector<T>::size_type vec_sz;
```

3. 系统环境如何处理模板的实例化的

> 所有的系统环境都会以它自己的特定的方式去处理实例化
> 只有模板被实例化了，系统环境才能证实，模板代码能被用于指定的类型。

- 对于那些沿用了传统的编辑-编译-连接模式的系统环境来说，实例化动作经常不是在编译期间而是在连接期间发生的。因此，在连接期间，我们就可以发现那些看起来在编译期间可能发生的错误

- 为了对一个模板进行实例化，当前的大多数系统环境都要求这个模板的定义（而不仅仅是声明）必须是系统环境可以访问的。许多系统环境都要求模板的头文件直接地或者通过 #include 指令而把源文件包含进去 