1. 自动转换

> 在类中定义类型转换包括两个方面的定义：把其他类型转换成该类类型，或者把该类类型转换成其他类型
> 更常用的转换定义是定义如何把其他类型转换成本类类型。通过定义一个只带有一个参数的构造函数来定义类型转换。

```cpp
// 编译器实际上调用 Str(const char*) 构造函数生成临时的 Str 类型对象；然后调用编译器自动生成的赋值运算符函数赋值
Str s="hello";
```

2. 友元函数

> 友元函数拥有和成员函数一样的访问权利。
> 友元函数的声明可以加载类定义的任何一个地方：把它加在一个 private 标识后面与加在一个 public 标识后面没有任何区别。
> 因为友元函数具有特殊的访问权利，所以他是类接口的一部分。因此，一般在类声明的前面，public 接口的附近，把所有友元函数的声明放在一起作为一个相对独立的组

```cpp
// 输入运算符函数是 Str 抽象概念的一部分，所以给该函数赋予对 data 的写权力是明智的。
// 另一方面，不想让所有用户对 data 数据拥有写的权利，所以不能通过把 data 作为 Str 类的一个公有数据成员来解决问题
istream &operator>>(istream &is, Str &s)
{
    s.data.clear();

    char c;
    // 忽略空白字符
    while (is.get(c) && isspace(c))
        ;
    if (is)
    {
        do
            s.data.push_back(c);
        while (is.get(c) && !isspace(c));
    }
    return is;
}
```

3. 混合类型表达式

```cpp
/**
 * 以下代码生成许多临时变量，对内存消耗极大，所以真正标准库中的 string 类不是依赖于自动转换来实现混合类型的操作符相加，
 * 而是重载加号操作数函数，为每一种可能的操作类型的连接定义一个版本
*/

Str greeting = "Hello," + name + "!";
// Str(const char*) 类型转换
Str temp1("Hello,");
// operator+(const Str&, const Str&)
Str temp2 = temp1 + name ;
// Str(const char*) 
Str temp3("!");
// operator+(const Str&, const Str&)
Str s = temp2 + temp3;
```

4. 赋值二元运算符函数

> 在赋值这个二元运算符函数里，规定左操作数的类型必须是该类的类型。
> 如果允许左操作数被转换，那么就可能会把操作数转换成该类的对象，并把它放在一个临时变量中，最后把一个新的值赋给这个临时变量。既然是一个临时变量，在赋值操作完成后，没有办法访问到刚才发生的这个对象！
> 因此，就像赋值运算符函数一样，所有的复合赋值操作也必须是类的成员函数。


5. 类型转换操作函数

> 该操作定义了如何把一个对象从原来的类型转换成一个希望得到的类型。转换操作必须定义成类的成员函数。
> 转换操作函数的函数名为 operator 加上目标类型名。
> operator double 成员函数，这个成员函数可以用来把一个该类类型的变量转换成 double 类型的变量。