1. 指针引发的问题

- 复制一个指针不会导致对指针所指对象的复制，当无意中使两个指针指向同一个对象时，常常会产生莫名其妙的结果
- 删除一个指针不会释放指针所指向对象所占用的内存，这常常导致内存泄露
- 删除一个对象但是没有删除指向该对象的指针会产生一个空悬指针（dangling pointer），在程序中使用这些指针的时候会导致未定义操作
- 如果定义一个指针但是不对它进行初始化，会使该指针没有指向任何地方，这时候如果程序中用到该指针，会导致未定义操作


2. 一个通用句柄类

- 一个 Handle 类型对象是一个指向某对象的值
- 我们可以对 Handle 类型对象进行复制
- 我们可以通过检测一个 Handle 类型对象来判断它是否指向另一个对象
- 如果一个 Handle 类型对象指向继承关系树中某各类的一个对象，我们可以用 Handle 类对象来触发多态行为。也就是说，如果通过 Handle 类来调用一个虚拟函数，我们希望程序在运行的时候能够动态地选择钓鱼用哪一个函数，就像是我们在通过一个真实的指针调用这个虚拟函数那样。


3. operator->

> C++语法要求我们定义一个 -> 运算符来返回一个可以看作是指针的值

```cpp
// 在定义 operator-> 函数的时候，如果 x 是定义 operator-> 函数的类的一个对象
x->y
// 等价于
(x.operator->()).y

```