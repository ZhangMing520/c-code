1. back_inserter

> 它用一个容器作为它的参数并产生一个迭代器，在生成的迭代器被用作一个目的地的时候，它会向容器末端添加数值。

```cpp
// bottom ret 都是容器
// 错误 - 在 ret.end() 没有元素
// copy 要做的第一件事是赋一个值给 ret.end() 中的元素。由于在此位置并不存在一个元素，系统环境将做些什么全凭我们的猜测了
// copy 按这种方式设计，是为了把复制元素和扩展一个容器的概念分离开来
// 正确 - ret.end() 替换为 back_inserter(ret)
copy(bottom.begin(), bottom.end(), ret.end());
```

2. find_if

> 算法的头两个参数是指示一个序列的迭代器；第三个参数则是一个谓词，它会检测自己的参数然后返回 true 或 false
> 如果我们查找的值存在的话，那么函数就会返回一个迭代器，这个迭代器指示了在给定的序列中第一次出现这个值的位置。如果找不到这个值，那么 find 就返回它的第二个参数。

3. equal

> 比较了两个序列以判断它们是否包含有相等的值。头两个迭代器指定了第一个迭代器。第三个参数是第二个序列的起点
> 假定第二个序列的长度与第一个相同，因此并不需要一个结尾迭代器

4. static

> 被声明为 static 的局部变量具有全局寿命，即其生存周期贯穿了整个函数调用过程。
> 因此，我们将仅仅在第一次调用 not_url_char 的时候构造并初始化字符串 url_ch，而随后的调用将使用第一次调用所构造的对象。

```cpp
static const string url_ch = "~;/?:@=&$-_.+!*’(),'";
```

5. find

> 算法的头两个参数是指示一个序列的迭代器，会查找由它的第三个参数所给定的特定值。
> 如果我们查找的值存在的话，那么函数就会返回一个迭代器，这个迭代器指示了在给定的序列中第一次出现这个值的位置。如果找不到这个值，那么 find 就返回它的第二个参数。

```cpp
static const string url_ch = "~;/?:@=&$-_.+!*’(),'";
// isalnum 字母或者数字
return !(isalnum(c) || find(url_ch.begin(), url_ch.end(), c) != url_ch.end());
```

6. search 
   
> 这个函数有两队迭代器参数：第一队指示了我们要查找的队列，而第二对则指示了一个序列--我们希望为这个序列定位。
> 如果 search 失败，那么它将返回第二个迭代器；因此，在调用了 search 之后，i 会指示紧位于输入字符串末尾之后的那个位置或者指示一个紧位于//之前的:

```cpp
static const string sep = "://";

i = search(i, e, sep.begin(), sep.end())
```

7. transform

> 参数是三个迭代器和一个函数。开头的两个迭代器指定了待转换元素的区间；第三个迭代器是一个目的地，它将保存函数的运行结果
> 调用 transform 的时候，我们要确保这个目的地有足够的空间以保存来自输入序列的值。通过调用 back_inserter 从而获得这个目的地的
> 第四个参数是一个函数，transform 将这个函数应用于输入序列的每个元素中以获得输出序列中的对应元素。不支持重载函数，编译器并不知道应该调用哪一个版本，因为我们没有给 grade 任何参数

8. accumulate

> 头两个参数指示了一个区间，而函数所做的工作是对区间中的值求和；函数的第三个参数所给定的值则是求和结果的开始。
> 和的类型就是第三个参数的类型，因此，使用了0.0而不是0 -- 这一点非常关键，否则，求和的结果将是一个 int 类型的值，而且所有的小数部分都将会丢失。

```cpp
#include <numeric>

accumulate(v.begin(), v.end(), 0.0) / v.size()
```

9. remove

> 查找与一个特定值匹配的所有值并把这些值从容器中“删除”掉


10. remove_copy

> 做了 remove 所做的工作，把符合结果的删除，但它会把不符合结果复制到一个指定的目的地
> 参数是三个迭代器和一个数值

```cpp
remove_copy(s.homework.begin(), s.homework.end(), back_inserter(nonzero), 0);
```

11. remove_copy_if

> 操作跟 remove_copy 相似，不同之处是，它使用了一个谓词而不是一个值来作为它的检测。

12. remove_if

> 返回一个迭代器，这个迭代器指向位于最后一个不被删除的元素后面的那个位置；
> 使用了同一个序列来作为它的源点和目的地，实际上它所做的是把不满足谓词的元素都复制到序列的开头

13. partition 和 stable_partition

> 它以一个序列作为参数并重新排列序列的元素，以使满足谓词的元素排在那些不满足谓词的元素之前
> partition 可能会在每一种类内部重新排列元素
> stable_partition 除了划分区域以外还会让各区域内的元素的相互顺序保持不变。
> 例如，如果学生的姓名已经是按照字母顺序排列好而且我们希望每一种类之内的姓名的相互顺序都不变的话，那我们就需要使用 stable_partition

```cpp
vector<Student_info>::iterator iter = stable_partition(students.begin(), students.end(), pgrade);
```

14. 算法、迭代器、容器

> 算法作用于容器的元素 -- 它们并不是作用于容器
> sort、remove_if 以及 partition 函数都会把基本容器中高的元素移动到新的位置，但是它们并没有改变容器本身的特性。 

15. 迭代器适配器

> 产生迭代器的函数。最常见的是那些产生迭代器 insert_iterators 的适配器，这样的迭代器会让关联的容器动态地增长。
> 这样的迭代器能被安全地用作一个复制算法的目的地。在头文件 \<iterator> 中定义

- back_inserter(c)  对容器 c 产生一个迭代器，这个迭代器会给 c 添加元素。这个容器必须支持链表、向量以及字符串类型都会支持的 push_back 操作
- front_inserter(c) 作用与 back_inserter 一样，但它是在容器的头部插入元素。这个容器必须支持 push_front 操作 -- 链表会支持这个操作，然而字符串和向量类型则不会。
- inserter(c, it)  作用与 back_inserter 一样，但它是在迭代器 it 之前插入元素