1. 派生类型对象构造步骤

- 为整个对象分配内存空间（包括基类中与派生类中定义的数据）
- 调用基类的构造函数以初始化对象中的基类部分数据
- 用构造初始化器对对象的派生类部分数据进行初始化
- 如果有的话，执行派生类构造函数的函数体

```cpp
// 执行这个语句会告诉系统为 Grad 类型对象 g 分配可以存储五个数据元素的内存空间，
// 然后运行 Core 类的默认构造函数对 g 对象的 Core 类部分数据成员进行初始化，最后调用 Grad 的默认构造函数 
Grad g
```

2. 多态

> 如果函数以指针作为参数，可以将指向 Grad 的指针传给它，编译器会将 Grad* 转换成 Core*，并将指针绑定到 Grad 对象中的 Core 部分。
> 如果函数以一个 Core 类型对象为参数，那么实际传递过去的只有对象的 Core 类部分。

3. virtual 
   
> virtual 关键字只能在类的定义里被使用。如果函数体在声明之外单独定义，我们不能在定义的时候重复 virtual 关键字。

4. 动态绑定

> 在通过一个指针或者一个引用调用虚拟函数的时候，我们实际上就在进行一个多态的调用

> 只有在以引用或者指针为参数调用虚拟函数的时候，它的运行时选择特性才会有意义。
> 如果我们以对象的名义调用一个虚拟函数，那我们就可以在编译的时候指导对象的类型，对象的类型一旦确定了，即使在运行的时候也不会改变。相反地，一个指向基类型对象的引用或指针可能是确实是指向一个基类型对象，也可能是指向该基类派生出来的类的对象，也就是说，引用或者指针指向对象的实际类型在运行的时候可以是变化的。

> 动态绑定（dynamic binding）顾名思义，就是指在运行的时候才决定调用什么函数，而不是在编译的时候就决定下来，那种情况属于静态绑定
> 如果以一个对象的名义调用一个虚拟函数，这个调用就是静态绑定的 -- 因为这个对象不可能在运行的时候改变为与编译时不同的类型。相反地，如果通过一个指针或者一个引用来调用虚拟函数，那么函数就是动态绑定的。

```cpp
Core c;
Grad g;
Core* p;
Core& r = g;

// 静态绑定
c.grade();
// 静态绑定
g.grade();
// 根据p所指对象的类型进行动态绑定
p->grade();
// 根据r所指对象的类型进行动态绑定，指向 Grad
r.grade();
```

5. 虚拟虚构函数

> 如果我们想用一个指向基类型对象的指针来删除一个实际上可能是派生类的对象，那么积累中就需要声明一个虚拟的析构函数。
   
> 注意到析构函数的函数体是空的。删除一个 Core 类型对象的唯一工作是删除对象的成员数据，系统会为我们自动完成这项工作。一个空的虚拟析构函数其实并不少见。
> 在所有通过一个指向基类的指针来删除一个派生类型对象的时候，都要用到虚拟析构函数。

```cpp
class Core{
public:
    virtual ~Core() {}
}
```

1. 静态成员函数

> 不能对类的对象进行操作。和其他的成员函数不同的是，静态成员函数与类关联，而不是与一个特定的类型对象关联。
> 因此，静态成员函数不能访问类型对象的非静态数据成员

> 函数名带有它们所属的类的限定词。所以当我们在声明一个 compare 为一个静态成员函数的时候，就是在声明一个叫做 Student_info::compare 的函数


7. 需要哪一个函数？

> 如果一个基类函数与一个派生类函数具有相同的函数名，但是两个函数的参数个数与参数类型都不相同，那么它们就像完全不相干的两个函数一样。
> 派生类中也有 regrade 这个成员函数，那么 Core 版本的 regrade 函数被隐藏了起来。
> 想要在一个派生类型对象中以一个基类型对象的名义调用这个版本的函数，就要对它进行显示地调用。

```cpp
void Core::regrade(double d) { finals = d;}
void Grad::regrade(double d, double d2) { finals = d1 ; thesis = d2; }

// r 是 Core 类型对象的引用
// 正常运行
r.regrade(100);
// 编译错误
r.regrade(100, 100);

// r 是 Grad 类型对象的引用
// 编译错误
r.regrade(100);
// 正常运行
r.regrade(100, 100);

// 正常运行
r.Core::regrade(100)
```