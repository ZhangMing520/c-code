1. explicit

> 只有在定义带一个参数的构造函数的时候才有意义。如果声明一个构造函数是 explicit 的，那么编译器只有在用户显式地使用构造函数时才会调用它，否则就不调用

```cpp
// 正确，显式地调用 Vec 的构造函数，以一个 int 类型数据作为参数
Vec<int> vi(100);

// 错误，隐式地调用 Vec 的构造函数，并把它复制到 vi
Vec<int> vi = 100;
```

2. 重载运算符

> 必须要有一个函数名，带几个参数，并指定其返回类型

> 重载一个运算符时，要把运算符放在关键词 operator 后面。也就是说，在这里要写成 operator [] 的形式

> 如果运算符是一个函数而不是一个成员，那么函数的参数个数与运算符的操作数一样多，第一个参数一定是左操作数，第二个参数一定是右操作数。如果运算符被定义成一个成员函数，那么它的左操作数必须是调用该运算符的对象。
> 可见，成员运算符函数比简单的运算符函数要少带一个参数

> 一般来说，运算符函数既可以是成员函数，也可以是非成员函数。但是索引运算符必须是成员函数

```cpp
// 看上去它们的参数列表是完全一样的；它们的参数都是一个 size_type 类型的变量。但是类中的每一个成员函数，包括这些运算符函数，都必须带一个隐式的参数作为作用对象。
// 因为操作的对象是常量，也可能不是常量，所以我们可以对运算符进行重载
T &operator[](size_type i) { return data[i]; }
const T &operator[](size_type i) const { return data[i]; }
```

3. 复制构造函数

> 复制构造函数只带一个参数，该参数与类本身具有相同的类型。

> 把一个对象的值作为参数传递给函数，或者从函数中通过传值返回一个对象，这就是在对对象进行隐式的赋值操作

```cpp
vector<int> vi;
double d; 
// 把 vi 作为参数传递给 median 函数
d = median(vi);

string line;
// 把 split 函数的返回值赋给 words
vector<string> words = split(line);
```

> 可以通过一个对象来初始化另外一个对象，从而显式地赋值对象

```cpp
vector<Student_info> vs;
// 将 vs 复制到 v2
vector<Student_info> v2 = vs;
```

```cpp
template <class T> class Vec{
public:
    // 复制构造函数
    Vec(const Vec& v);
}
```

4. 赋值运算符

> 一个指向类自身的常量引用作为参数的版本比较特殊：它定义了在把一个自定义类型值（对象）赋给另一个自定义类型（对象）时的操作。
> 赋值运算符必须是类的一个成员函数。必须有一个返回值。

> 赋值操作与赋值构造函数不同，赋值总是把一个已经存在的值（运算符左侧的对象）擦去，然后代之以一个新的值（运算符右侧的对象）。而在进行复制时，先创建一个新的对象，所以不需要对一个已经存在的对象进行删除操作。


5. 定义一个模板成员函数的语法

> 在除了类的头文件以外的地方定义一个模板成员函数的语法。定义返回类型时，用的是 Vec\<T> &。在头文件中定义时用的是 Vec& 类型，不需要显式地声明返回类型名称。因为在模板文件的范围内，C++允许我们忽略其具体类型名称。

> 在头文件外面，必须声明返回类型，所以要在必要的地方显式地写出模板参数。
> 类似地，函数名 Vec\<T>::operator=，不能简写成 Vec::operator=。
> 不过，一旦在前面指定定义是一个 Vec\<T>类型的成员函数，后面就不需要重复使用这个定语了。因此，在参数列表中把参数写成 const Vec& 的形式，而不必写成 const Vec\<T> & 这样的复杂形式。

```cpp
template <class T>
Vec<T> &Vec<T>::operator=(const Vec &rhs){}
```

6. this 

> this 关键词只有在成员函数内部才有效，代表指向函数操作的对象的指针

7. 赋值与初始化

> 等号“=”既可以用来初始化又可以用来赋值。在使用“=”为一个变量赋一个初始值的时候，程序自动调用赋值构造函数。而在赋值表达式中，程序调用 operator= 赋值操作函数。

> 主要区别：赋值（operator=函数）总是删除一个旧的值；而初始化则没有这步操作。初始化包括创造一个新的对象并同时给它一个初始的值。下面的时候会发生初始化：
   - 声明一个变量的时候
   - 在一个函数的入口处用到函数参数的时候
   - 函数返回中使用函数返回值的时候
   - 在构造初始化的时候

```cpp
// 初始化
string url_ch = "abcdefg";
// 初始化
string spaces(url_ch.szie(),' ');

// 初始化
string y;
// 赋值
y = url_ch;
```

8. 三位一体（rule of three）

> 如果类需要一个析构函数，那么它同时可能需要一个复制构造函数与一个复制运算符函数

9. new的弊端

- 如果使用了 new 和 delete 运算符，写出来的 Vec 类使用起来就要受到诸多限制，就不如标准向量类的使用范围那么广了。

- C++ 内建的 new 运算符要做许多工作：既要分配新的内存空间，又要对新内存进行初始化。在为一个类型为 T 的数组分配空间时，需要去调用 T 的默认构造函数。

- 使用 new 运算符还可能会为程序带来过多的资源开销。使用 new ，它会使用 T::T() 构造函数来为一个类型为 T 的数组中的每一个元素都进行初始化。如果想用自己提供的数据来初始化 Vec 类型对象的元素的话，实现上要进行两次初始化 -- 一次是 new 自动进行的，另一次是在把用户提供的数值赋给 Vec 类型对象的元素时进行的。

10. allocator

> 在 \<memory> 头文件中提供了一个名为 allocator\<T> 的类，它可以分配一块预备用来储存 T 类型对象但是尚未被初始化的内存块，并返回一个指向这块内存块的头元素的指针。

```cpp
template <class T> class allocator{
public:
    // 用来分配一块被制定了类型但却未被初始化的内存块
    T* allocate(size_t);
    // 用来释放未被初始化的内存
    T* deallocate(T*, size_t);
    // 用来在 allocate 申请分配但尚未初始化的内存区域上进行初始化，生成单个的对象
    T* construct(T*, T);
    // 用来删除这个对象
    T* destroy(T*);
};

// 对 allocate 所分配的内存进行初始化
// 向内存块中填充一个指定的值
void uninitialized_fill(T*, T*, const T&);
// 把前两个参数指针所指向的内存区间中的值复制到第三个参数指针所指向的目标内存块中
T* uninitialized_copy(T*, T*, T*);
```