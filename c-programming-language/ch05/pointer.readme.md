1. 指针
> 一种用于存放另一个变量的地址的变量

- 一个字节可表示一个字符，一对相连的存储单元可表示一个短整数，而四个相邻的字节则构成一个长整数
- 由能存放一个地址的一组存储单元（通常是2个或者4个字节）构成
- 一个指针只能指向一个特定类型的对象；每一个指针对象也有一确定的数据类型

2. & 
> 取地址运算符只能用于内存中的对象（即变量与数组元素），它不能对表达式、常量或者寄存器变量进行操作

3. *
> 间接寻址或间接引用运算符，当它应用于指针时，它将访问指针所指向的对象

4. 指针类型说明
> int \*ip 表达式*ip是int类型的
> double *dp, atof(char \*) 表达式\*dp和atof(s)都具有double类型的值，并且atof的参数是一个指向char类型的指针

5. 数组和指针

- 一个数组的名字即该数组第0个元素的位置 pa=a 等价于 pa=&a[0]
- 对数组元素a[i]的引用可以写成*(a+i)。在求数组元素a[i]的值时，C语言实际上先将其转换成*(a+i)的形式然后再求值
- 指针是变量，pa=a和pa++都是合法的；数组名字不是变量，a=pa和a++这样的语句是非法的
- 数组名字参数对应的变元是一个包含地址值的局部变量
- 在函数定义中将 char s[]和 char *s 作为函数的形式参数所表示的含义是等价的
- 指针和整数不能相互转换，但是0例外：常量0可以赋给指针，指针也可以和常量0进行比较。程序中经常使用符号常量NULL代替常量0

6. 有效的指针运算

- 相同类型指针之间的赋值运算
- 指针值加或减一个整数值的运算
- 指向相同数组中的元素的指针之间的减或比较运算
- 将指针赋0或指针与0之间的比较运算

7. 非法的指针运算
- 指针间的加法、乘法、除法、移位或屏蔽运算
- 指针值加单双精度浮点数的运算
- 除两者之一是void*类型指针外，不经强制类型转换就将指向一个类型对象的指针赋值给指向另一种类型对象的指针的运算

8. 复杂声明

|声明|表达意思|
|:--:|:--:|
|char **argv | argv 指向字符指针的指针|
|int (*daytab) [13] | daytab 指向由13个整数类型元素组成的一维数组的指针|
|int *daytab [13] | daytab 由13个指向整数类型对象的指针组成的一维数组|
|void * comp() | comp 返回值为指向通用类型的指针的函数|
|void (*comp)() | comp 指向返回值为指向通用类型的函数的指针|
|char (\*(*x()) []) () | x 返回值为指向一维数组的指针的函数，该一维数组由指向返回字符类型的函数的指针组成 |
|char (\*(*x\[3]())) [5] | x 由3个指向函数的指针组成的一维数组，该函数返回指向由5个字符组成的一维数组的指针|

9. 指针数组
- 最频繁的用处是存放具有不同长度的字符串
- int *b[10] 定义仅仅分配了10个指针而且没有对它们进行初始化，它们的初始化必须以静态的方式或用代码显示进行